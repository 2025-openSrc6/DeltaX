# Sui 가이드: 백엔드 개발자를 위한 핵심 개념

이 문서는 Sui 블록체인에 익숙하지 않은 백엔드 개발자가 **"Sponsored Transaction(가스 대납) + User Signature(유저 서명)"** 구조를 이해하고 구현하기 위해 작성되었습니다.

---

## 1. 🔍 큰 그림 (Big Picture)

백엔드 개발자인 당신의 역할은 **"계약서 작성자(Builder)"**이자 **"집행자(Executor)"**입니다.
유저는 단지 **"서명자(Signer)"**일 뿐입니다.

### 비유: "법인 카드 결제 기안서"

1.  **당신(백엔드)**이 기안서(Transaction)를 작성합니다. "누가, 얼마를, 어디에 쓴다"는 내용입니다.
2.  **유저(임직원)**에게 기안서를 보여줍니다. 유저는 내용을 확인하고 **"내 이름 서명"**을 찍습니다. (아직 돈은 안 나감)
3.  **유저**가 서명된 기안서를 당신에게 돌려줍니다.
4.  **당신(백엔드)**은 이 기안서에 **"회계팀(Sponsor) 도장"**을 추가로 찍어서 은행(블록체인)에 제출합니다.
5.  **은행(Sui)**은 두 개의 도장(유저+회계팀)을 확인하고 돈을 이체합니다.

---

## 2. 🧩 핵심 용어 완전 정복

### 2.1 PTB (Programmable Transaction Block) = "기안서 양식"

Sui의 트랜잭션은 단순한 "송금"이 아닙니다. **"프로그래밍 가능한 명령 묶음"**입니다.

- "A함수를 실행하고, 그 결과로 나온 객체를 B함수에 넣고, 남은 돈은 C에게 보내라."
- 이 모든 과정을 하나의 꾸러미(Block)로 묶은 것이 PTB입니다.
- **백엔드의 역할**: 코드로 이 PTB를 조립하는 것입니다. (`tx.moveCall(...)`)

### 2.2 직렬화 (Serialization) = "봉투에 밀봉하기"

- **문제**: 백엔드(Node.js)에서 만든 PTB 객체는 자바스크립트 객체입니다. 이걸 유저의 지갑(브라우저)이나 블록체인으로 그대로 보낼 수 없습니다.
- **해결**: 이 객체를 **바이트 배열(010101...)**로 변환하는 과정을 직렬화라고 합니다. (Sui에서는 BCS라는 규칙을 씀)
- **Result**: `txBytes` (Base64 문자열).
  - 이 `txBytes`가 바로 **"변조할 수 없는 기안서 원본"**입니다. 유저는 이 문자열에 서명하게 됩니다.

### 2.3 서명 (Signature) = "도장 찍기"

- **유저 서명**: `Sign(txBytes, UserPrivateKey)` -> "나는 이 `txBytes` 내용에 동의하며, 내 코인(Object)을 사용해도 좋다."
- **스폰서 서명**: `Sign(txBytes, SponsorPrivateKey)` -> "나는 이 `txBytes`를 실행하는 데 드는 **가스비(수수료)**를 내겠다."
- Sui는 **Multi-Signature(다중 서명)**를 지원하므로, 하나의 트랜잭션에 두 명의 서명을 붙여서 제출할 수 있습니다.

---

## 3. 🛠️ 백엔드 개발자가 해야 할 일 (실전)

두 개의 API만 만들면 됩니다. **준비(Prepare)**와 **실행(Execute)**입니다.

### Step 1. 준비 API (`POST /api/sui/bet/tx`)

유저가 "나 베팅할래!"라고 요청하면, 당신은 **기안서를 작성**해서 건네줍니다.

1.  **PTB 생성**:
    ```typescript
    const tx = new TransactionBlock();
    // "베팅 함수를 호출해라" 명령 추가
    tx.moveCall({
      target: '패키지::모듈::place_bet',
      arguments: [ pool, 코인, 예측값... ]
    });
    ```
2.  **직렬화**:

    ```typescript
    // 중요: "이 트랜잭션의 가스비는 나(스폰서)가 낼 거야"라고 명시
    tx.setSender(userAddress);
    tx.setGasOwner(sponsorAddress);

    // 바이트로 변환
    const txBytes = await tx.build({ client: suiClient });
    ```

3.  **반환**: 프론트엔드에게 `txBytes` (Base64)를 줍니다.

### Step 2. 실행 API (`POST /api/sui/bet/execute`)

유저가 지갑에서 서명한 뒤, **서명값**을 들고 다시 찾아옵니다.

1.  **요청 받기**: `txBytes` (원본), `userSignature` (유저 도장).
2.  **스폰서 서명**:
    ```typescript
    // 나(서버)도 도장을 찍습니다.
    const sponsorSig = await sponsorKeypair.signTransactionBlock(txBytes);
    ```
3.  **최종 제출**:
    ```typescript
    // 블록체인에 제출 (서명 두 개를 배열로 전달)
    client.executeTransactionBlock({
      transactionBlock: txBytes,
      signature: [userSignature, sponsorSig.signature],
    });
    ```

---

## 4. ⚡️ 심화: Strict PTB와 당신이 고민해야 할 것들

네가 물어본 **"Strict PTB"**와 **"직렬화의 함정"**에 대해 더 깊이 알아봅시다. 이 부분이 바로 백엔드 개발자가 가장 많이 실수하는 부분입니다.

### 4.1 "Strict Immutability" (절대 불변의 법칙)

한번 `txBytes`로 직렬화되어 유저 서명을 받는 순간, **그 바이트는 단 1비트도 수정할 수 없습니다.**

**Q: "가스비는 스폰서(서버)가 내니까, 서버가 나중에 GasBudget을 올려도 되지 않나요?"**
**A: "안 됩니다."**

이유는 **유저가 서명하는 대상** 때문입니다.
유저는 단순히 "베팅한다"는 사실뿐만 아니라, **"가스 예산은 100원이고, 스폰서는 누구다"**라는 정보가 모두 포함된 **전체 데이터(TransactionData)**에 서명합니다.

- 서버가 나중에 GasBudget을 100원 -> 200원으로 고치면?
- `TransactionData`의 내용이 변합니다.
- 유저가 찍어준 도장(서명)은 "100원짜리 데이터"에 대한 도장이므로, **"200원짜리 데이터"와 불일치**하게 됩니다.
- 결국 블록체인은 "이 서명 위조됐는데?"라고 판단하고 거절합니다.

* **상황**: 당신이 기안서(txBytes)를 만들어서 유저에게 줬습니다. 유저가 도장을 찍어왔는데, 갑자기 Sui 가스비가 폭등해서 예산(GasBudget)을 좀 늘려야 할 것 같습니다.
* **실수**: "서버에서 제출하기 직전에 `tx.setGasBudget(더_높은값)` 해서 보내면 안 되나?"
* **결과**: **서명 불일치 에러 (Invalid Signature)**.
  - 유저는 "X 내용을 실행하는 데 100원까지 쓴다"는 내용에 서명했습니다.
  - 당신이 이걸 "200원"으로 바꾸면, 바이트가 바뀌고, 유저의 서명은 휴지조각이 됩니다.
* **교훈**: 처음 `prepare` 단계에서 가스비를 넉넉하게 잡거나, 정확하게 예측해서 `txBytes`를 만들어야 합니다. 수정은 불가능합니다.

### 4.2 "Expiration" (유효기간 문제)

Sui 트랜잭션은 영원하지 않습니다. (기본값은 짧지 않지만, Epoch 단위로 만료될 수 있습니다.)

- **고민점**: 유저가 `prepare` API를 호출하고, 밥을 먹고 와서 1시간 뒤에 서명해서 `execute`를 호출하면?
- **문제**: 그 사이 체인의 상태가 변했거나(예: 베팅 라운드 종료), 가스 가격(Reference Gas Price)이 변했을 수 있습니다.
- **해결**: 서버에서 자체적으로 `expiresAt` 타임스탬프를 짥게(예: 5분) 잡아서 줍니다. 만료되면 "재요청하세요"라고 해야 합니다.

### 4.3 "Shared Object Congestion" (공유 객체 줄서기)

우리의 `BettingPool`은 **Shared Object(공유 객체)**입니다. 수천 명이 동시에 베팅합니다.

- Sui는 빠르지만, 같은 객체를 동시에 수정하려고 하면 **줄(Sequence)**을 세웁니다.
- 너무 많은 사람이 동시에 몰리면, 내 트랜잭션이 처리가 지연될 수 있습니다.
- 하지만 다행히 Sui는 **Consensus 엔진**이 강력해서 대부분 잘 처리합니다. 다만, "즉시 완료"가 보장되지 않을 수 으니, 프론트엔드에서는 "처리 중(Pending)" 상태를 잘 보여줘야 합니다.

### 요약: 백엔드 개발자의 체크리스트

1.  **가스 예산(GasBudget)**: `prepare` 단계에서 충분히 넉넉하게 잡을 것. (나중에 수정 불가)
2.  **재시도(Retry) 금지**: `execute` 단계에서 실패했을 때, 무턱대고 재시도하면 안 됨. (이미 처리되었는데 네트워크 문제로 응답만 못 받은 경우, 다시 보내면 에러남. 멱등성 중요.)
3.  **상태 확인**: `prepare` 할 때뿐만 아니라, `execute` 들어왔을 때도 "아직 베팅 가능한가?"(시간 체크)를 한 번 더 해야 함. (PTB 실행 시점엔 컨트랙트도 체크하지만, DB를 아끼기 위해)

## 5. 🚦 궁금증 해결: "간발의 차이로 늦으면?"

**Q: "유저가 베팅 버튼 누르고 서명하는 사이에 라운드가 마감되면 어떡하나요?"**

**상황**:

1.  **09:59:50**: 유저가 "베팅 준비" 요청 (서버 OK).
2.  **09:59:55**: 서버가 `txBytes` 반환.
3.  **10:00:01**: 유저가 고민하다가 서명해서 `execute` 요청. (이미 라운드 마감 10:00:00 지남)

**A: "네, 그냥 죄송하다고 하고 쳐내면(Reject) 됩니다."**

이것이 블록체인의 단호함이자 장점입니다.

1.  **서버 방어**: `execute` API에서 `round.lock_time`을 체크하고, 지났으면 `400 Bad Request` ("Round Closed")를 리턴합니다.
2.  **컨트랙트 방어**: 만약 서버가 실수로 통과시켜도, **Move 컨트랙트** 내부에서 `assert!(clock.timestamp_ms() < pool.lock_time, E_TOO_LATE)`가 동작하여 트랜잭션이 **강제 실패(Abort)**합니다.

즉, **"늦으면 늦은 것"**입니다. 유저에게는 "마감 시간이 지나 베팅이 실패했습니다"라고 명확히 알려주는 것이 정답입니다.

---

## 6. 🛡️ 미래의 당신을 위한 조언 (Proactive Advice)

네가 "더 고민할 부분 없냐"고 물어서, 미리 겪게 될 **두 가지 골칫거리**를 예방 주사로 놓아드립니다.

### 6.1 "Coin Selection & Equivocation" (동전 고르기 문제)

유저가 지갑에 `100 DEL`, `50 DEL` 짜리 동전을 가지고 있습니다.

- 베팅 1 (100 DEL): 서버가 `100 DEL` 동전을 골라서 PTB를 만듭니다.
- 베팅 2 (50 DEL): 유저가 동시에 또 베팅을 시도합니다. 만약 서버가 **또 `100 DEL` 동전을 골라버리면?**
- **결과**: 첫 번째 베팅은 성공하지만, 두 번째 베팅은 **"Coin Object Version Mismatch"** 에러로 무조건 실패합니다. (이미 썼으니까!)
- **해결**: 서버에서 `prepare` 할 때, **"사용 가능한(Available) 코인"**을 똑똑하게 골라야 합니다. (이건 나중에 `lib/sui` 짤 때 다룰 겁니다. 그냥 "아 코인 관리가 중요하구나" 정도만 알면 됨.)

### 6.2 "Pre-Execution Safety" (실행 전 시뮬레이션)

유저한테 서명하라고 팝업을 띄웠는데, 막상 서명했더니 에러가 나면 유저는 화가 납니다.

- **팁**: `prepare` API에서 `txBytes`를 만들기 전에, 서버 내부적으로 **"Dry Run(모의 실행)"**을 한번 돌려보는 게 좋습니다.
- Sui는 가스비 없이 결과를 미리 볼 수 있는 `dryRunTransactionBlock` 기능을 제공합니다. 여기서 에러가 나면 아예 프론트한테 `txBytes`를 주지 말고 "베팅 불가(잔액 부족 등)" 에러를 뱉는 게 UX상 훨씬 좋습니다.

---

여기까지 이해했다면, 당신은 이미 **Sui 백엔드 개발 상위 10%**입니다.

## 7. 💀 "왜 어렵다고 했나?" (The Reality Check)

"문서만 보면 별거 아닌데 왜 위험하다고 했을까?"
**행복 회로(Happy Path)**만 보면 쉽습니다. 하지만 **현실(Production)**은 지옥일 수 있습니다. 우리가 마주할 진짜 위험요소들입니다.

### 7.1 동시성 관리 (The Concurrency Hell)

- **상황**: 유저가 1초에 5번 따다다닥 베팅 버튼을 누름.
- **문제**: 서버가 5번 모두 같은 `Coin Object A(100 DEL)`를 사용하여 `txBytes`를 만들어줌.
- **결과**: 첫 번째만 성공하고 나머지 4개는 **"Object Version Mismatch"**로 폭망.
- **해결책**: 백엔드가 유저의 사용 가능한 모든 Coin을 조회해서, **"이 코인은 지금 1번 트랜잭션에 썼으니까, 2번 트랜잭션엔 저 코인을 써야지"**라고 **코인 잠금(Locking)** 관리를 직접 해야 함.

### 7.2 상태 불일치 (State Drift)

- **상황**: 블록체인에는 베팅이 성공했는데(돈 빠져나감), 우리 DB(D1)에 저장하는 순간 서버가 죽음.
- **결과**: 유저는 "돈은 나갔는데 왜 내 베팅 내역이 없죠?"라고 항의.
- **해결책**: 주기적으로 체인을 스캔해서 누락된 걸 채워넣는 **"Indexer/Recovery Job"**이 필수.

### 7.3 스폰서의 죽음 (Sponsor Failure)

- **상황**: 스폰서 지갑에 가스비(SUI)가 떨어짐.
- **결과**: 서비스 **전면 중단**. 아무도 베팅 못함.
- **해결책**: 스폰서 잔액 모니터링 알림을 아주 빡세게 걸어야 함.

### 결론

지금 이해한 "흐름"은 완벽합니다. 구현 자체는 `lib/sui`에 짜면 됩니다.
다만, **"동시성(코인 관리)"**과 **"에러 복구"** 로직을 꼼꼼히 짜야 하는 게 진짜 남은 숙제입니다.
우리는 초기 단계이므로 리커버리 잡까지는 아니더라도, **"코인 충돌 방지"** 정도는 신경 써서 구현해야 합니다.

---

## 8. 🪙 심화: "코인 충돌" 상세 분석 및 결정 가이드

네가 물어본 **"그래서 지금 이거 구현해야 해?"**에 대한 답을 드리기 위해, 충돌의 종류를 두 가지로 나눴습니다.

### 8.1 충돌 종류: 내 돈 vs 니 돈

#### (A) 유저 코인 충돌 (User Coin Collision)

- **상황**: 유저 한 명이 동시에 베팅 2개를 시도함.
- **위험도**: `Low`.
- **이유**: 우리 비즈니스 로직(Next.js)이 **"한 라운드에 베팅 1번만 가능"**하게 막고 있습니다. 게다가 사용자가 많지 않으면 한 사람이 미친듯이 클릭할 일도 없습니다.
- **결론**: 이건 **무시해도 됩니다.** 그냥 프론트에서 버튼 비활성화만 잘 하면 됩니다.

#### (B) 스폰서 가스 충돌 (Sponsor Gas Collision) -> **이게 핵심!**

- **상황**: 철수와 영희가 **동시에** 베팅 버튼을 누름.
- **문제**:
  1.  서버(`prepare`): "철수 트랜잭션 수수료는 **가스동전-A**로 낼게." (서명 완료)
  2.  서버(`prepare`): "영희 트랜잭션 수수료도 **가스동전-A**로 낼게." (서명 완료)
  3.  **결과**: 철수가 먼저 제출되면 `가스동전-A`의 버전이 올라갑니다. 뒤따라온 영희의 트랜잭션은 **"옛날 버전 가스동전-A"**를 쓰고 있으므로 **실패**합니다.
- **위험도**: `High`. (유저가 단 2명이어도 동시에 누르면 터짐)

### 8.2 해결책 및 결정 (Decision)

그럼 엄청 복잡한 Lock 시스템을 짜야 하느냐? **아닙니다.**
우리는 **"Demo ~ MVP 단계"**이므로, 아주 쉬운 꼼수(Trick)로 해결합니다.

#### 💡 꼼수: "가스통 쪼개기 (Split Gas)"

1.  스폰서 지갑에 `100 SUI` 짜리 동전 하나만 두지 말고, `1 SUI` 짜리 동전 **50개**를 만들어 둡니다.
2.  서버(`prepare`)가 가스비를 낼 때, 50개 중에 **랜덤으로 하나**를 골라서 씁니다.
3.  동시 접속자가 50명을 넘지 않는 한 충돌 확률은 거의 0입니다.

#### ✅ 최종 가이드

1.  **유저 코인 관리**: 구현하지 마세요. (1라운드 1베팅 제약으로 충분)
2.  **스폰서 가스 관리**: 복잡한 Lock 대신, **"가스 동전 많이 쪼개두기 + 랜덤 선택"** 로직만 `lib/sui`에 살짝 넣읍시다. 이걸로 충분합니다.

지금은 이걸로 막고, 나중에 서비스가 커지면 **9번(Best Practice)**으로 넘어가면 됩니다.

---

## 9. 🏆 Global Best Practices (진짜 고수들은 어떻게 하나?)

나중에 서비스가 대박나서 동시접속자가 10만 명이 되면 "가스통 쪼개기"로는 부족합니다.
그때를 위해 **업계 표준 아키텍처(Sui Coin Manager)**를 남겨둡니다.

### 9.1 DB를 이용한 "Coin Locking System"

블록체인은 느리기 때문에, **빠른 DB(Redis/SQL)**를 캐시 레이어로 씁니다.

1.  **Coin Table**: 스폰서가 가진 모든 동전(Object ID)을 DB에 저장합니다.
    - Columns: `object_id`, `balance`, `status` (AVAILABLE, LOCKED), `locked_until`
2.  **Locking Query**: 트랜잭션을 만들 때 DB에서 "사용 가능한 동전" 하나를 가져오면서 **서버단 Lock**을 겁니다.
    - `UPDATE coins SET status='LOCKED', locked_until=NOW()+10s WHERE id=(SELECT id FROM coins WHERE status='AVAILABLE' LIMIT 1 FOR UPDATE)`
3.  **Use**: 락 걸린 동전으로 PTB를 만듭니다.
4.  **Release**: 트랜잭션이 체인에 제출되면(성공하든 실패하든) 해당 동전을 다시 `AVAILABLE`로 풉니다. (단, 버전이 바뀌었으므로 `Indexer`가 새 버전을 감지해서 업데이트해줘야 함)

### 9.2 아키텍처 요약

- **Small Scale (Current)**: Random Selection (확률에 의존, 구현 난이도 하)
- **Large Scale (Future)**: Database Locking (DB 트랜잭션 보장, 구현 난이도 상)

지금은 **Small Scale**로 충분합니다. 하지만 "몰라서 안 하는 것"과 "알지만 효율을 위해 미루는 것"은 다릅니다. 당신은 이제 후자입니다. 😎

이제 마음 편하게 다음 단계(구현)로 가도 됩니다! 🚀
